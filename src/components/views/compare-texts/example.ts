import type { TextConfig } from ".";

export const example: {
  inputJson: string,
  textConfigs: TextConfig[],
} = {
  textConfigs: [
    { label: "Gemini 2.0 Flash", path: "gemini_2-0-flash.output", isMarkdown: true },
    { label: "Open AI 4O", path: "openai_4o.output", isMarkdown: true },
    { label: "Claude 3.7 Sonnet", path: "claude_3-7-sonnet.output", isMarkdown: true },
    { label: "Claude 3.5 Sonnet", path: "claude_3-5-sonnet.output", isMarkdown: true },
  ],
  inputJson: JSON.stringify({
    "gemini_2-0-flash": {
      "output": "OK. Here's a structured breakdown of the video tutorial on React Server Components, focusing on the steps taken to optimize a Next.js application for speed, interactivity, and user experience.\n\n### **Introduction**\n\nThe video presents a tutorial on React Server Components (RSC) and how they can be used to improve the performance and user experience of web applications. The presenter starts with a demo application built using Next.js, Prisma, and Tailwind CSS, which initially has performance issues due to slow data fetching. The goal is to optimize this application using RSCs and new features from React 19 and Next.js.\n\n### **Chapter 1: Initial Assessment and Setup**\n\n1.  **Demo Application Overview**:\n    *   The application is a project task manager built with the Next.js app router, Prisma ORM, PostgreSQL database, and Tailwind CSS.\n    *   All components are initially server components by default.\n    *   The initial load is slow due to intentionally slowed-down data fetches.\n    *   The application functions without JavaScript, using native web features.\n2.  **Lighthouse Score Review**:\n    *   The initial Lighthouse score shows poor First Contentful Paint (FCP) and Largest Contentful Paint (LCP) at 3.6 seconds due to the slow initial load.\n    *   Speed Index is also 3.6 seconds.\n    *   Total Blocking Time (TBT) is zero, indicating low JavaScript execution time.\n    *   Cumulative Layout Shift (CLS) is zero because everything paints at once.\n3.  **Starting Files**:\n    *   **Root Layout**: A server component that asynchronously fetches project and task summary data directly from the database.\n        *   The data fetching functions use `await connection API` from Next.js and are intentionally slowed down.\n    *   **Project Info Component**: Displays project information.\n    *   **Status Tabs Component**: Displays status tabs.\n    *   **Search Component**: A form for searching tasks.\n    *   **Dynamic Route (Page)**: A dynamic route for displaying tasks based on filters.\n\n### **Chapter 2: Improving UX with Suspense**\n\n1.  **Addressing Slow Tab Navigation**:\n    *   The presenter addresses the slow tab navigation by implementing `Suspense`.\n    *   The goal is to mark components as non-urgent and stream them in with a fallback.\n2.  **Creating a Loading Component**:\n    *   A `loading.tsx` file is created in the directory to act as a fallback.\n\n    *   This file contains a simple skeleton UI to be displayed while the component is loading.\n\n    *   When a tab is clicked, the fallback is displayed while the component streams in.\n\n### **Chapter 3: Parallelizing Data Fetches**\n\n1.  **Identifying the Bottleneck**:\n    *   The initial load is blocked by data fetches in the root layout.\n    *   Data fetches are running sequentially, even though they are independent.\n2.  **Moving Data Fetches to Components**:\n    *   The data fetching logic is moved from the root layout to the respective components (`ProjectInfo` and `StatusTabs`).\n    *   The `getProject` and `getTaskSummary` functions are moved into these components.\n    *   The root layout no longer needs to fetch this data.\n3.  **Implementing Suspense**:\n    *   `Suspense` components are added around the `ProjectInfo` and `StatusTabs` components.\n    *   A simple \"Loading...\" fallback is initially used.\n4.  **Benefits**:\n    *   Data fetches now run in parallel, significantly reducing the initial load time.\n    *   The page loads instantly, showing the fallback UI while the data is fetched.\n\n### **Chapter 4: Addressing Cumulative Layout Shift (CLS)**\n\n1.  **Identifying the Issue**:\n    *   The initial \"Loading...\" fallbacks cause visual instability and Cumulative Layout Shift (CLS).\n2.  **Sizing Fallbacks Correctly**:\n    *   Instead of the simple \"Loading...\" text, properly sized skeleton UIs are used as fallbacks.\n    *   `project-info-skeleton` and `status-tabs-skeleton` components are used.\n    *   The skeleton UIs match the dimensions of the actual content.\n3.  **Result**:\n    *   The page is now visually stable during loading, eliminating CLS.\n    *   The user experience is improved as the page layout doesn't shift when content loads.\n\n### **Chapter 5: Enhancing User Experience with Client-Side Interactivity**\n\n1.  **Adding Active Tab Indication**:\n    *   The goal is to highlight the currently active tab in the `StatusTabs` component.\n2.  **Using `useParams` Hook**:\n    *   The `useParams` hook from `next/navigation` is used to get the current tab from the dynamic route parameters.\n3.  **Converting to Client Component**:\n    *   Since `useParams` is a hook, the `StatusTabs` component needs to be a client component.\n    *   The `use client` directive is added at the top of the file.\n4.  **Handling Asynchronous Data Fetching**:\n    *   Client components cannot be asynchronous, so the data fetching logic cannot be directly used inside `StatusTabs`.\n    *   The `getTaskSummary` function is moved back to the layout, but instead of awaiting the promise, it's passed down to `StatusTabs` as a promise.\n5.  **Using the `use` Hook**:\n    *   The `StatusTabs` component uses the `use` hook from React 19 to read the value of the promise.\n    *   This allows the component to suspend while the promise is resolving, similar to `await`.\n6.  **Result**:\n    *   The active tab is now correctly highlighted.\n    *   The component suspends while waiting for the data, ensuring a smooth user experience.\n\n### **Chapter 6: Improving the Search Form**\n\n1.  **Default Form Behavior**:\n    *   The default HTML form behavior causes a full page reload when submitting the search query.\n2.  **Using the `next/form` Component**:\n    *   The `Form` component from `next/form` is used to enable client-side navigation.\n    *   The `action` prop is set to the current page to stay on the same page after submission.\n3.  **Adding Progressive Enhancement with `onChange`**:\n    *   An `onChange` handler is added to the input field to update the URL as the user types.\n4.  **Using `useRouter` and `useSearchParams`**:\n    *   The `useRouter` hook from `next/navigation` is used to access the router.\n    *   The `useSearchParams` hook from `next/navigation` is used to access the current search parameters.\n5.  **Updating the URL**:\n    *   The `onChange` handler creates new search params based on the existing ones and pushes them to the router using `router.push`.\n    *   The `URL` state is used to ensure the app's state is reloadable, bookmarkable, and shareable.\n6.  **Setting Default Value and Resetting the Form**:\n    *   The `query` parameter is used to set the default value of the input field.\n    *   A `key` prop is added to reset the form whenever the active tab changes.\n\n### **Chapter 7: Adding Transition and Pending State**\n\n1.  **Identifying the Issue**:\n    *   The URL updates are delayed because the filtering happens on the server.\n    *   Users need feedback to know that something is happening after their interaction.\n2.  **Using `useTransition` Hook**:\n    *   The `useTransition` hook from React 18 is used to mark the state update as non-urgent and get the pending state.\n    *   The `startTransition` function is used to wrap the `router.push` call.\n3.  **Displaying a Spinner**:\n    *   The `pending` state from `useTransition` is used to trigger a spinner while the transition is happening.\n    *   This provides visual feedback to the user.\n4.  **Result**:\n    *   The spinner is displayed while the new page is loading, improving the user experience.\n\n### **Chapter 8: Implementing Category Filter**\n\n1.  **Adding the Category Filter Component**:\n    *   A new component called `CategoryFilter` is added.\n    *   This component displays a list of categories and allows users to filter tasks by category.\n2.  **Fetching Categories**:\n    *   The categories are fetched using the `getCategories` function.\n    *   The promise is passed down to the component as a prop.\n3.  **Using Suspense**:\n    *   The `CategoryFilter` component is wrapped in a `Suspense` component with a skeleton fallback.\n4.  **Using Search Params**:\n    *   The component uses the search params as the single source of truth for the selected categories.\n    *   It manipulates the search params in a similar way to the search form.\n5.  **Addressing Delayed Updates**:\n    *   Clicking on the category filters also results in delayed updates because the filtering happens on the server.\n6.  **Using Transition for Pending State**:\n    *   The `useTransition` hook is used to mark the state update as non-urgent.\n    *   The `startTransition` function is used to wrap the `router.push` call.\n7.  **Displaying a Pulsey Animation**:\n    *   A `data-pending` attribute is added to the div containing the table.\n    *   CSS is used to display a pulsing animation when the `data-pending` attribute is present.\n    *   This provides feedback to the user that the content is being updated.\n\n### **Chapter 9: Optimistic Updates with `useOptimistic`**\n\n1.  **Using `useOptimistic` Hook**:\n    *   The `useOptimistic` hook from React 19 is used to provide optimistic updates to the category filters.\n    *   This makes the UI feel more responsive.\n2.  **Setting Optimistic Categories**:\n    *   The `useOptimistic` hook returns the `optimisticCategories` and a function to set them.\n    *   The `optimisticCategories` are used as the selected values in the component.\n    *   The `setOptimisticCategories` function is called before pushing to the router inside the transition.\n3.  **Benefits**:\n    *   The UI updates instantly when a category filter is clicked, even before the server responds.\n    *   The `useOptimistic` hook creates a temporary client state that is thrown away when the transition completes and settles to the truth of the URL.\n\n### **Chapter 10: Caching and Performance Improvements**\n\n1.  **Identifying Duplicate Data Fetching**:\n    *   The `getCategories` function is being called twice per render, once in the layout and once in the `getTaskSummary` function.\n2.  **Using the `cache` API**:\n    *   The `cache` API from React 19 is used to perform per-render caching for the `getCategories` function.\n    *   This ensures that the function is only called once per render.\n3.  **Enabling Client-Side Caching**:\n    *   Client-side caching is enabled in the `next.config.js` file using `staleTime`.\n    *   This caches dynamic page segments for a specified amount of time, avoiding needless server component renders.\n4.  **Using Partial Pre-rendering**:\n    *   Partial pre-rendering is enabled in the `next.config.js` file.\n    *   The `Suspense` boundary around the `ProjectInfo` component is removed.\n    *   The `await connection` call is removed from the `getProject` function.\n5.  **Benefits**:\n    *   The `ProjectInfo` component is now statically rendered, resulting in a faster FCP and LCP.\n    *   The application feels much faster and more responsive.\n\n### **Chapter 11: Alternative Approach with NuxtJS**\n\n1.  **Using `useQueryState` in NuxtJS**:\n    *   The presenter briefly demonstrates an alternative approach using NuxtJS.\n    *   The `useQueryState` composable is used to simplify search param handling.\n    *   The `shallow: false` option is used to trigger a server request.\n2.  **Benefits**:\n    *   NuxtJS simplifies search param handling and fixes certain race conditions.\n    *   The code is much cleaner and easier to maintain.\n\n### **Chapter 12: Best Practices and Summary**\n\n1.  **Resolving Promises in Components**:\n    *   Resolve promises deeper in the component tree while displaying loading fallbacks with `Suspense`.\n    *   This improves performance metrics and user experience.\n    *   Size suspense fallbacks correctly to avoid CLS.\n2.  **Displaying Pending Indicators**:\n    *   Display pending indicators using transitions to give the user immediate feedback.\n3.  **Putting Application State in the URL**:\n    *   Put application state in the URL to allow the app to be reloaded, bookmarked, and shared.\n4.  **Using Progressive Enhancement**:\n    *   Use progressive enhancement to ensure the app is functional even before JavaScript has loaded.\n5.  **Utilizing React 19 Features**:\n    *   Use the `use` API to suspend client components as they resolve a promise.\n    *   Use `useOptimistic` to respond to user interactions instantly.\n    *   Use the `cache` API to perform per-render caching.\n6.  **Enabling Next.js Features**:\n    *   Use client-side caching with `staleTime` to avoid needless server component renders.\n    *   Use partial pre-rendering to statically render pieces of the application.\n"
    },
    "openai_4o": {
      "output": "## React Server Components: Elevating Speed, Interactivity, and User Experience\n\nIn this comprehensive tutorial led by Aurora Scharff, we dive deep into utilizing React Server Components, focusing on improving application speed, interactivity, and user experience. Aurora provides a detailed explanation of new development patterns and features incorporated in React and Next.js to achieve these improvements.\n\n### Introduction to React Server Components\n- **Server Components Overview**: React Server Components only run on the server, unlike conventional client-side components or server-side rendering. They can fetch data asynchronously and access backend resources directly, reducing the JavaScript bundle size on the client for more performant applications.\n- **Demo Application Setup**: The example used is a task manager application demonstrating the benefits of server components. The setup includes Next.js app router, Prisma for ORM, and Tailwind for CSS. The initial load is purposefully slow to demonstrate optimization possibilities.\n\n### Optimizing User Experience and Performance\n1. **Initial Load Optimization**:\n   - Observed a slow initial load due to sequential data fetches.\n   - **Method**:\n     - Data fetches were moved into the respective components (ProjectInfo and TaskSummary).\n     - Implemented `suspense` and fallbacks for these components to allow parallel data fetching and partial content display.\n\n2. **Reducing Layout Shifts**:\n   - Implemented correctly sized skeletons for fallback content to prevent cumulative layout shifts.\n\n3. **Enhancing User Interactions**:\n   - Integrated a useParams hook for dynamic routes to manage the active tab, requiring conversion of the component to a client component.\n   - **Solution for Asynchronous Components**:\n     - Data fetching was adjusted from the server parent component and passed down as promises. React’s new `use` API was used to suspend components until the promise resolved.\n\n4. **Search Functionality Improvement**:\n   - Improved search experience with client-side navigation using Next.js's new `next-form` component.\n   - Implemented an on-change handler to update search parameters without full page reload.\n\n5. **Adding Transitions for Immediate Feedback**:\n   - Used React’s `useTransition` to mark non-urgent updates and provide immediate feedback (spinners) during state transitions.\n\n6. **Further Performance and User Experience Enhancements**:\n   - **Caching with React and Next.js**:\n     - Implemented `cache` from React 19 for per-render caching to avoid redundant calls per render cycle.\n     - Stale-time caching for reuse of dynamic page segments avoided unnecessary server component renders.\n   - **Partial Pre-rendering**:\n     - Employed partial pre-rendering for infrequently changing content, allowing for static rendering and faster content display.\n\n7. **Advanced Optimizations with NX**:\n   - Shifted to using `Nux.js` for easier handling of search params and race conditions.\n\n### Best Practices and Summary\n- **Development Patterns**:\n  - Resolve promises within deeper components, using suspense to improve FCP, LCP, and speed index.\n  - Introduce pending state indicators for better user feedback.\n  - Centralize application state within URLs (enables state reloadability and bookmarking).\n  - Use progressive enhancement, ensuring functionality even before JavaScript and hydration are complete.\n  \n- **React 19 and Next.js Features**:\n  - Embrace new React 19 features like `use`, `useOptimistic`, and `cache` for efficient data handling and restful UI experiences.\n  - Leverage Next.js features like stale-time caching and partial pre-rendering for faster, more efficient applications.\n\nFor more in-depth code and use cases, Aurora's repository and blog provide further resources and explorations into advanced React 19 capabilities. By following these guidelines and innovations, developers can create significantly more interactive, faster, and user-friendly web applications."
    },
    "claude_3-7-sonnet": {
      "output": "# React Server Components: Elevating Speed, Interactivity, and User Experience\n\n## Introduction to React Server Components\n\nReact 19, released in December, introduced Server Components - a fundamentally different approach to building React applications. Server Components:\n\n- Only run on the server or during build time, never on the client\n- Are never hydrated, resulting in partially hydrated applications\n- Cannot use state, effects, or browser APIs\n- Have powerful capabilities that make them worth adopting\n\nKey advantages of Server Components:\n\n1. **Asynchronous operation**: Components can fetch their own data asynchronously\n2. **Direct backend access**: They can access database resources directly\n3. **Reduced bundle size**: JavaScript is never shipped to the client, improving performance\n\n## Basic Server Component Example\n\n```jsx\nasync function ProjectInfo() {\n  const project = await prisma.project.findUnique({\n    where: { id: 1 }\n  });\n  \n  return (\n    <div>\n      <h1>{project.name}</h1>\n      <p>{project.description}</p>\n    </div>\n  );\n}\n```\n\nThis server component queries a database through Prisma ORM and renders the data before sending it to the client.\n\n## Demo Project Overview\n\nThe demonstration uses a project task manager application built with:\n- Next.js App Router\n- Prisma as ORM\n- PostgreSQL database\n- Tailwind CSS\n\nInitial performance issues:\n- Very slow initial load (artificially slowed for demonstration)\n- First Contentful Paint (FCP): 3.6 seconds\n- Largest Contentful Paint (LCP): 3.6 seconds\n- Speed Index: 3.6 seconds\n- Total Blocking Time: 0 (good)\n- Cumulative Layout Shift: 0 (good)\n\nThe goal is to improve the slow scores while maintaining the good ones.\n\n## Improving the Application\n\n### Step 1: Adding Loading States with Suspense\n\nFirst, we add a loading state for the tabs navigation using Next.js loading files:\n\n```jsx\n// loading.tsx\nexport default function Loading() {\n  return (\n    <div className=\"skeleton\">\n      {/* Skeleton loading state */}\n    </div>\n  );\n}\n```\n\nThis provides immediate feedback when users click tabs, showing a fallback while streaming in the actual component.\n\n### Step 2: Pushing Data Fetches Down the Component Tree\n\nInstead of fetching data in the layout (which blocks rendering), move data fetching to the components that need it:\n\n**Before:**\n```jsx\n// layout.tsx\nasync function Layout() {\n  const project = await getProject();\n  const taskSummary = await getTaskSummary();\n  \n  return (\n    <>\n      <ProjectInfo project={project} />\n      <StatusTabs taskSummary={taskSummary} />\n      {children}\n    </>\n  );\n}\n```\n\n**After:**\n```jsx\n// layout.tsx\nfunction Layout() {\n  return (\n    <>\n      <Suspense fallback={<div>Loading...</div>}>\n        <ProjectInfo />\n      </Suspense>\n      <Suspense fallback={<div>Loading...</div>}>\n        <StatusTabs />\n      </Suspense>\n      {children}\n    </>\n  );\n}\n\n// ProjectInfo.tsx\nasync function ProjectInfo() {\n  const project = await getProject();\n  return <div>{/* Render project info */}</div>;\n}\n\n// StatusTabs.tsx\nasync function StatusTabs() {\n  const taskSummary = await getTaskSummary();\n  return <div>{/* Render tabs */}</div>;\n}\n```\n\nThis approach:\n- Makes components responsible for their own data\n- Collocates data with UI\n- Allows components to load in parallel\n- Shows content immediately while streaming in the data\n\n### Step 3: Sizing Suspense Fallbacks Correctly\n\nBasic \"Loading...\" fallbacks caused layout shifts (CLS increased from 0 to 0.04). To fix this:\n\n```jsx\n// layout.tsx\nfunction Layout() {\n  return (\n    <>\n      <Suspense fallback={<ProjectInfoSkeleton />}>\n        <ProjectInfo />\n      </Suspense>\n      <Suspense fallback={<StatusTabsSkeleton />}>\n        <StatusTabs />\n      </Suspense>\n      {children}\n    </>\n  );\n}\n```\n\nThe skeleton components have the same dimensions as the actual components, preventing layout shifts during loading.\n\n### Step 4: Highlighting the Active Tab\n\nTo show the currently active tab, we need client-side JavaScript:\n\n```jsx\n\"use client\"\n\nimport { useParams } from 'next/navigation';\n\nfunction StatusTabs({ taskSummaryPromise }) {\n  const params = useParams();\n  const activeTab = params.tab;\n  const taskSummary = use(taskSummaryPromise);\n  \n  return (\n    // Render tabs with activeTab highlighted\n  );\n}\n```\n\nKey changes:\n- Added \"use client\" directive\n- Used useParams() hook to get the active tab\n- Cannot use async/await in client components\n- Used React 19's `use` hook to read the promise passed from the server component\n\n### Step 5: Enhancing the Search Form\n\nImproved the search form with progressive enhancements:\n\n```jsx\n\"use client\"\n\nimport { useRouter, useSearchParams } from 'next/navigation';\nimport { useTransition } from 'react';\nimport { NextForm } from 'next/form';\n\nfunction Search() {\n  const searchParams = useSearchParams();\n  const router = useRouter();\n  const [isPending, startTransition] = useTransition();\n  const query = searchParams.get('q') || '';\n  const activeTab = searchParams.get('tab') || 'all';\n  \n  function handleChange(e) {\n    const newParams = new URLSearchParams(searchParams);\n    newParams.set('q', e.target.value);\n    \n    startTransition(() => {\n      router.push(`?${newParams.toString()}`);\n    });\n  }\n  \n  return (\n    <NextForm action=\"\">\n      <input \n        value={query}\n        onChange={handleChange}\n        key={activeTab} // Reset form when tab changes\n      />\n      {isPending && <Spinner />}\n    </NextForm>\n  );\n}\n```\n\nKey improvements:\n1. Used Next.js Form for client-side navigation, avoiding full page reloads\n2. Added onChange handler for instant searching\n3. Used URL as the source of truth for state\n4. Added useTransition to mark updates as non-urgent and show loading indicators\n5. Reset form when tab changes\n\n### Step 6: Adding a Category Filter Component\n\nAdded a new category filter component with optimistic UI updates:\n\n```jsx\n\"use client\"\n\nimport { useSearchParams, useRouter } from 'next/navigation';\nimport { useTransition, useOptimistic } from 'react';\nimport { use } from 'react';\n\nfunction CategoryFilter({ categoriesPromise }) {\n  const searchParams = useSearchParams();\n  const router = useRouter();\n  const [isPending, startTransition] = useTransition();\n  const categories = use(categoriesPromise);\n  \n  const selectedCategories = searchParams.getAll('category') || [];\n  const [optimisticCategories, setOptimisticCategories] = useOptimistic(\n    selectedCategories\n  );\n  \n  function handleCategoryClick(category) {\n    const newParams = new URLSearchParams(searchParams);\n    \n    if (optimisticCategories.includes(category)) {\n      newParams.delete('category', category);\n      setOptimisticCategories(\n        optimisticCategories.filter(c => c !== category)\n      );\n    } else {\n      newParams.append('category', category);\n      setOptimisticCategories([...optimisticCategories, category]);\n    }\n    \n    startTransition(() => {\n      router.push(`?${newParams.toString()}`);\n    });\n  }\n  \n  return (\n    <div data-pending={isPending ? '' : undefined}>\n      {categories.map(category => (\n        <button \n          key={category}\n          className={optimisticCategories.includes(category) ? 'active' : ''}\n          onClick={() => handleCategoryClick(category)}\n        >\n          {category}\n        </button>\n      ))}\n    </div>\n  );\n}\n```\n\nKey features:\n1. Used `useOptimistic` to create temporary"
    },
    "claude_3-5-haiku": {
      "output": "Here's a structured tutorial based on the video transcript about React Server Components and performance optimization:\n\n# React Server Components: Performance and User Experience Tutorial\n\n## Overview\nThis tutorial demonstrates how to build a task management application using Next.js App Router, React Server Components, and modern performance optimization techniques.\n\n## Technology Stack\n- Next.js App Router\n- Prisma (ORM)\n- PostgreSQL Database\n- Tailwind CSS\n- React 19 Features\n\n## Initial Setup Challenges\n- Slow initial page load\n- Sequential data fetching\n- Poor user experience\n- No progressive loading\n\n## Performance Optimization Strategies\n\n### 1. Suspense and Parallel Data Loading\n- Move data fetching into individual components\n- Use Suspense for loading states\n- Create loading skeletons for components\n- Code example:\n```javascript\n// Project Info Component\nasync function ProjectInfo() {\n  const projectData = await fetchProjectData(); // Moved from layout\n  return <div>{/* Render project data */}</div>;\n}\n```\n\n### 2. Preventing Cumulative Layout Shift (CLS)\n- Create precisely sized loading skeletons\n- Match fallback size to actual content\n- Use CSS to maintain page stability\n\n### 3. Client-Side Navigation Enhancements\n- Use Next.js Form component for client-side navigation\n- Implement onChange handler\n- Use `useTransition` for pending states\n- Example:\n```javascript\nfunction SearchForm() {\n  const [isPending, startTransition] = useTransition();\n  \n  function handleChange(event) {\n    startTransition(() => {\n      // Update router\n    });\n  }\n}\n```\n\n### 4. State Management with URL\n- Store application state in URL\n- Makes application reloadable and shareable\n- Use `useSearchParams` for state management\n\n### 5. Optimistic Updates\n- Use `useOptimistic` hook\n- Provide instant UI feedback\n- Handle network-independent interactions\n\n### 6. Caching Strategies\n- Use `cache` API for per-render caching\n- Enable stale times for dynamic segments\n- Reduce unnecessary server component re-renders\n\n### 7. Partial Pre-Rendering\n- Experimental Next.js feature\n- Statically render parts of application\n- Improve First Contentful Paint (FCP)\n\n## Performance Metrics Improvements\n- Reduced First Contentful Paint to 0.1 seconds\n- Zero total blocking time\n- Zero cumulative layout shift\n- 99% Lighthouse performance score\n\n## Best Practices\n1. Resolve promises in deeper component tree\n2. Display pending indicators\n3. Use URL as single source of truth\n4. Progressive enhancement\n5. Minimal client-side JavaScript\n\n## Recommended React 19 and Next.js Features\n- `use` API for suspending components\n- `useOptimistic` for instant interactions\n- `cache` for function memoization\n- Stale-time caching\n- Partial pre-rendering\n\n## Bonus: Alternative Implementation\n- Demonstrated NUX (Next.js User Experience) approach\n- Simplified state management\n- Reduced code complexity\n\n## Conclusion\nReact Server Components offer powerful performance optimization techniques by:\n- Reducing client-side JavaScript\n- Improving initial load times\n- Providing better user experience\n- Enabling progressive enhancement"
    },
    "claude_3-5-sonnet": {
      "output": "Here's a structured summary of the video tutorial on React Server Components:\n\n1. Introduction to React Server Components\n\nReact Server Components are components that only run on the server or during build time, never on the client. They differ from server-side rendering because they are never hydrated. Key features include:\n\n- Can be asynchronous and fetch their own data\n- Can access backend resources directly\n- Reduce bundle size as JavaScript is not shipped to the client\n\n2. Setting up the Demo Application\n\nThe demo uses:\n- Next.js App Router\n- Prisma as ORM\n- Prisma Postgres as database\n- Tailwind for CSS\n\n3. Initial Application Structure\n\n- Root layout (server component)\n- Project info component\n- Status tabs component\n- Search component\n- Dynamic route for task table\n\n4. Improving Performance and User Experience\n\nStep 1: Adding Loading State\n- Created a loading.tsx file with a skeleton component\n- Implemented suspense for non-urgent components\n\nStep 2: Parallelizing Data Fetches\n- Moved data fetches from root layout to individual components\n- Used suspense to provide fallbacks while components load\n\nStep 3: Fixing Cumulative Layout Shift (CLS)\n- Created properly sized skeleton components for Project Info and Status Tabs\n\nStep 4: Implementing Active Tab Indication\n- Used useParams hook to get the active tab\n- Converted Status Tabs to a client component (use client directive)\n- Passed task summary as a promise to Status Tabs component\n- Used React 19's 'use' API to handle the promise in the client component\n\nStep 5: Enhancing Search Functionality\n- Replaced default form with Next.js Form component for client-side navigation\n- Implemented onChange handler to update URL on each keystroke\n- Used useTransition for non-urgent state updates and to show loading indicators\n\nStep 6: Adding Category Filter\n- Created a new Category Filter component\n- Implemented suspense and fallback for this component\n- Used useTransition for smooth updates\n- Implemented optimistic updates using useOptimistic hook\n\nStep 7: Implementing Caching\n- Used React 19's cache API for per-render caching of expensive function calls\n- Enabled stale times in Next.js config for caching dynamic page segments\n\nStep 8: Partial Pre-rendering (Experimental)\n- Removed suspense boundary around Project Info\n- Enabled partial pre-rendering in Next.js config\n- Built and deployed to Vercel to demonstrate instant loading of static content\n\n5. Final Improvements and Alternative Approach\n\n- Demonstrated improved Lighthouse scores\n- Introduced an alternative implementation using Nux for easier state management and URL handling\n\n6. Best Practices Summary\n\n- Resolve promises deeper in the component tree\n- Display pending indicators for user feedback\n- Use URL as a single source of truth for application state\n- Implement progressive enhancement\n\n7. New React and Next.js Tools\n\n- React 19: use API, useOptimistic, cache API\n- Next.js: Client-side caching with stale times, partial pre-rendering (experimental)\n\nThe tutorial demonstrates how to leverage these new features to create fast, interactive, and user-friendly React applications using server components."
    }
  }),
};